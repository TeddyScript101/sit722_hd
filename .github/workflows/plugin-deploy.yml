name: Plugin - Deploy to AKS

on:
  workflow_call:
    inputs:
      NAMESPACE:
        required: true
        type: string
      IMAGE_TAG:
        required: true
        type: string
      STAGING:
        required: false
        type: boolean
        default: false
    secrets:
      AZURE_CREDENTIALS:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      ACR_LOGIN_SERVER:
        required: true
      EMAIL_USER:
        required: true
      EMAIL_PASSWORD:
        required: true

env:
  RESOURCE_GROUP: sit722devopsteddy-rg
  AKS_NAME: sit722devopsteddy-aks

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Create Namespace
        run: kubectl create namespace ${{ inputs.NAMESPACE }} || echo "Namespace exists"

      - name: Deploy Backend Services
        run: |
          for service in order_service product_service; do
            K8S_NAME=$(echo $service | sed 's/_/-/g')
            TARGET_PORT=8000
            TYPE=LoadBalancer
            if [ "${{ inputs.STAGING }}" = "true" ]; then TYPE=ClusterIP; fi

            kubectl create deployment $K8S_NAME \
              --image=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

            kubectl expose deployment $K8S_NAME \
              --type=$TYPE \
              --port=80 \
              --target-port=$TARGET_PORT \
              --name=$K8S_NAME \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

            kubectl label deployment $K8S_NAME app=$K8S_NAME -n ${{ inputs.NAMESPACE }} --overwrite
            kubectl set image deployment/$K8S_NAME *=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}
          done

      - name: Wait for Backend Deployments
        run: |
          for dep in $(kubectl get deployments -n ${{ inputs.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}'); do
            kubectl rollout status deployment/$dep -n ${{ inputs.NAMESPACE }} --timeout=300s
            kubectl wait --for=condition=Ready pod -l app=$dep -n ${{ inputs.NAMESPACE }} --timeout=180s
          done

      - name: Deploy Frontend
        run: |
          docker build -t $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} frontend/
          echo ${{ secrets.ACR_PASSWORD }} | docker login $ACR_LOGIN_SERVER -u ${{ secrets.ACR_USERNAME }} --password-stdin
          docker push $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }}

          TYPE=LoadBalancer
          if [ "${{ inputs.STAGING }}" = "true" ]; then TYPE=ClusterIP; fi

          kubectl create deployment frontend \
            --image=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} \
            -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

          kubectl expose deployment frontend \
            --port=80 \
            --target-port=80 \
            --type=$TYPE \
            --name=frontend \
            -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

          kubectl label deployment frontend app=frontend -n ${{ inputs.NAMESPACE }} --overwrite
          kubectl set image deployment/frontend *=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}

      - name: Wait for Frontend Deployment
        run: kubectl rollout status deployment/frontend -n ${{ inputs.NAMESPACE }} --timeout=300s

      - name: Log Service External IPs
        run: |
          echo "üåê Checking service IPs in namespace ${{ inputs.NAMESPACE }}..."
          for svc in frontend order-service product-service; do
            TYPE=$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.spec.type}')
            if [ "$TYPE" = "LoadBalancer" ]; then
              EXTERNAL_IP=""
              while [ -z "$EXTERNAL_IP" ]; do
                EXTERNAL_IP=$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                [ -z "$EXTERNAL_IP" ] && echo "Waiting for $svc external IP..." && sleep 5
              done
              echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
            else
              echo "‚ÑπÔ∏è $svc is ClusterIP only"
            fi
          done

  post-deploy-integration-tests:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd util
          npm ci

      - name: Run API Integration Tests
        run: |
          echo "üîó Setting up dynamic port forwarding..."
          SERVICES=("product-service" "order-service" "frontend")
          START_PORT=18000
          declare -A PORT_MAPPING

          for service in "${SERVICES[@]}"; do
            SERVICE_PORT=$(kubectl get svc $service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.spec.ports[0].port}')
            LOCAL_PORT=$START_PORT
            START_PORT=$((START_PORT + 1))
            echo "üöÄ Forwarding $service: localhost:$LOCAL_PORT -> service port $SERVICE_PORT"
            kubectl port-forward svc/$service $LOCAL_PORT:$SERVICE_PORT -n ${{ inputs.NAMESPACE }} &
            PORT_MAPPING[$service]=$LOCAL_PORT
          done

          for service in "${SERVICES[@]}"; do
            PORT=${PORT_MAPPING[$service]}
            echo "‚è≥ Waiting for $service on localhost:$PORT..."
            for i in {1..20}; do
              if curl -s http://localhost:$PORT/health; then
                echo "‚úÖ $service is responding at localhost:$PORT"
                break
              else
                sleep 3
              fi
            done
          done

          export PRODUCT_API_IP="http://localhost:${PORT_MAPPING["product-service"]}"
          export ORDER_API_IP="http://localhost:${PORT_MAPPING["order-service"]}"
          export FRONTEND_URL="http://localhost:${PORT_MAPPING["frontend"]}"

          echo "üß™ Running integration tests..."
          cd util
          npm test --testTimeout=30000 || true

      - name: Cleanup Port-Forwards and Namespace
        if: ${{ always() }}
        run: |
          echo "üßπ Cleaning up port-forwards..."
          pkill -f "kubectl port-forward" || true

          if [ "${{ inputs.STAGING }}" = "true" ]; then
            echo "üóëÔ∏è Deleting namespace..."
            kubectl delete namespace ${{ inputs.NAMESPACE }} || echo "Namespace already deleted"

  notify-email:
    needs: post-deploy-integration-tests
    uses: ./.github/workflows/plugin-send-email.yml
    with:
      email_to: "teddyhinyp@gmail.com"
      email_subject: ${{ needs.deploy.result == 'success' && 'Deployment Succeeded' || 'Deployment Failed' }}
      email_body: |
        Deployment to namespace ${{ inputs.NAMESPACE }} has completed.
        Status: ${{ needs.deploy.result }}
        Image Tag: ${{ inputs.IMAGE_TAG }}
        Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    secrets:
      EMAIL_USER: ${{ secrets.EMAIL_USER }}
      EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
