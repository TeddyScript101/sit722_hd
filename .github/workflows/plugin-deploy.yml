name: Plugin - Deploy to AKS

on:
  workflow_call:
    inputs:
      NAMESPACE:
        required: true
        type: string
      IMAGE_TAG:
        required: true
        type: string
      STAGING:
        required: false
        type: boolean
        default: false
    secrets:
      AZURE_CREDENTIALS:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      ACR_LOGIN_SERVER:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      RESOURCE_GROUP: sit722devopsteddy-rg
      AKS_NAME: sit722devopsteddy-aks
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Create Namespace
        run: kubectl create namespace ${{ inputs.NAMESPACE }} || echo "Namespace exists"

      - name: Deploy Backend Services
        run: |
          for service in order_service product_service; do
            K8S_NAME=$(echo $service | sed 's/_/-/g')
            kubectl create deployment $K8S_NAME \
              --image=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            # Use ClusterIP for testing, LoadBalancer for production
            if [ "${{ inputs.STAGING }}" = "false" ]; then
              TYPE=LoadBalancer
            else
              TYPE=ClusterIP
            fi
            kubectl expose deployment $K8S_NAME \
              --type=$TYPE \
              --port=80 --target-port=80 --name=$K8S_NAME \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            kubectl label deployment $K8S_NAME app=$K8S_NAME -n ${{ inputs.NAMESPACE }} --overwrite
            kubectl set image deployment/$K8S_NAME *=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}
          done

      - name: Wait for Backend Deployments
        run: |
          DEPLOYMENTS=$(kubectl get deployments -n ${{ inputs.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}')
          for dep in $DEPLOYMENTS; do
            kubectl rollout status deployment/$dep -n ${{ inputs.NAMESPACE }} --timeout=300s
            # Wait for pods to be ready
            kubectl wait --for=condition=Ready pod -l app=$dep -n ${{ inputs.NAMESPACE }} --timeout=120s
          done

      - name: Get Backend External IPs
        run: |
          PRODUCT_API_IP=$(kubectl get svc product-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          ORDER_API_IP=$(kubectl get svc order-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "PRODUCT_API=$PRODUCT_API_IP" >> $GITHUB_ENV
          echo "ORDER_API=$ORDER_API_IP" >> $GITHUB_ENV

      - name: Inject Backend IPs into Frontend main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|http://$PRODUCT_API:80|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://$ORDER_API:80|g" frontend/main.js

      - name: Build and Push Frontend Image
        run: |
          docker build -t $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} frontend/
          echo ${{ secrets.ACR_PASSWORD }} | docker login $ACR_LOGIN_SERVER -u ${{ secrets.ACR_USERNAME }} --password-stdin
          docker push $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          kubectl create deployment frontend --image=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          TYPE=LoadBalancer
          if [ "${{ inputs.STAGING }}" = "true" ]; then
            TYPE=ClusterIP
          fi
          kubectl expose deployment frontend --port=80 --target-port=80 --name=frontend -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl set image deployment/frontend *=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}
          kubectl label deployment frontend app=frontend -n ${{ inputs.NAMESPACE }} --overwrite

      - name: Wait for Frontend Deployment
        run: kubectl rollout status deployment/frontend -n ${{ inputs.NAMESPACE }} --timeout=300s

  post-deploy-integration-tests:
    needs: deploy
    runs-on: ubuntu-latest
    env:
      RESOURCE_GROUP: sit722devopsteddy-rg
      AKS_NAME: sit722devopsteddy-aks
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Add Azure login and AKS connection for this job
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd util
          npm ci

      - name: Run Staging Tests
        run: |
          echo "üß™ Running tests..."
          # Frontend
          kubectl port-forward service/frontend-service 8080:80 -n $STAGING_NAMESPACE &
          PF_PID=$!
          sleep 10
          curl -f -s http://localhost:8080 && echo "‚úÖ Frontend responding" || echo "‚ö†Ô∏è Frontend not responding"
          kill $PF_PID 2>/dev/null || true

          # Backend
          for svc in customer-service order-service product-service; do
            POD=$(kubectl get pods -n $STAGING_NAMESPACE -l app=$svc -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$POD" ]; then
              kubectl wait --for=condition=ready pod/$POD -n $STAGING_NAMESPACE --timeout=120s
              echo "‚úÖ $svc pod ready"
            else
              echo "‚ö†Ô∏è $svc pod not found"
            fi
          done

      # - name: Run API integration tests
      #   run: |
      #     echo "üîó Setting up port forwarding for integration tests..."

      #     # Start port forwarding in background for services
      #     for service in product-service order-service frontend; do
      #       PORT=""
      #       LOCAL_PORT=""
      #       case $service in
      #         product-service) LOCAL_PORT=8000; PORT=80 ;;
      #         order-service) LOCAL_PORT=8001; PORT=80 ;;
      #         frontend) LOCAL_PORT=8080; PORT=80 ;;
      #       esac

      #       echo "üöÄ Starting port-forward for $service svc on $LOCAL_PORT:$PORT"
      #       kubectl port-forward svc/$service $LOCAL_PORT:$PORT -n ${{ inputs.NAMESPACE }} &

      #       # Store the PID for cleanup
      #       PID=$!
      #       echo "PORT_FORWARD_PID_$service=$PID" >> $GITHUB_ENV
      #     done

      #     # Wait for port-forwards to establish
      #     echo "‚è≥ Waiting for port-forwards to establish..."
      #     sleep 20

      #     # Verify connections
      #     echo "üîç Verifying port-forward connections..."
      #     for port in 8000 8001 8080; do
      #       if nc -z localhost $port 2>/dev/null; then
      #         echo "‚úÖ Port $port is accessible"
      #       else
      #         echo "‚ùå Port $port is not accessible"
      #       fi
      #     done

      #     # Set environment variables for tests
      #     export PRODUCT_API_IP="http://localhost:8000"
      #     export ORDER_API_IP="http://localhost:8001"
      #     export FRONTEND_URL="http://localhost:8080"

      #     echo "üß™ Running integration tests..."
      #     cd util
      #     npm test --testTimeout=30000 || true

      - name: Cleanup
        if: ${{ always() }}
        run: |
          # Only clean up if not production, or if previous steps failed
          if [[ "${{ inputs.STAGING }}" == "true" || "${{ job.status }}" == "failure" ]]; then
            echo "üßπ Cleaning up port-forwards..."
            pkill -f "kubectl port-forward" || true

            echo "üóëÔ∏è Deleting namespace..."
            kubectl delete namespace ${{ inputs.NAMESPACE }} || echo "Namespace already deleted"
          else
            echo "‚úÖ Skipping cleanup for production success."
          fi

  notify-email:
    needs: post-deploy-integration-tests
    uses: ./.github/workflows/plugin-send-email.yml
    with:
      email_to: "teddyhinyp@gmail.com"
      email_subject: ${{ needs.deploy.result == 'success' && 'Production Deployment Succeeded' || 'Production Deployment Failed' }}
      email_body: |
        Deployment to namespace ${{ github.event.inputs.NAMESPACE }} has completed.
        Status: ${{ needs.deploy.result }}
        Image Tag: ${{ github.event.inputs.IMAGE_TAG }}
        Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    secrets:
      EMAIL_USER: ${{ secrets.EMAIL_USER }}
      EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
