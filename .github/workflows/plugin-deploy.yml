# Fixed version of plugin-deploy.yml
name: Plugin - Deploy to AKS

on:
  workflow_call:
    inputs:
      NAMESPACE:
        required: true
        type: string
      IMAGE_TAG:
        required: true
        type: string
      STAGING:
        required: false
        type: boolean
        default: false
    secrets:
      AZURE_CREDENTIALS:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      ACR_LOGIN_SERVER:
        required: true
      EMAIL_USER:
        required: true
      EMAIL_PASSWORD:
        required: true

env:
  RESOURCE_GROUP: sit722devopsteddy-rg
  AKS_NAME: sit722devopsteddy-aks

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Create Namespace
        run: kubectl create namespace ${{ inputs.NAMESPACE }} || echo "Namespace exists"

      # -------------------------------
      # Update image tags in YAML files
      # -------------------------------
      - name: Update Image Tags
        run: |
          # Update product service image
          sed -i 's|image: teddysit722hd.azurecr.io/product_service:latest|image: ${{ secrets.ACR_LOGIN_SERVER }}/product_service:${{ inputs.IMAGE_TAG }}|g' k8s/product-service.yaml

          # Update order service image  
          sed -i 's|image: teddysit722hd.azurecr.io/order_service:latest|image: ${{ secrets.ACR_LOGIN_SERVER }}/order_service:${{ inputs.IMAGE_TAG }}|g' k8s/order-service.yaml

          # Update frontend image
          sed -i 's|image: teddysit722hd.azurecr.io/frontend:latest|image: ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ inputs.IMAGE_TAG }}|g' k8s/frontend.yaml

      # -------------------------------
      # Update service types for staging
      # -------------------------------
      - name: Update Service Types for Staging
        if: ${{ inputs.STAGING == true }}
        run: |
          # Change LoadBalancer to ClusterIP for staging
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/product-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/order-service.yaml  
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/frontend.yaml

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n ${{ inputs.NAMESPACE }}

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n ${{ inputs.NAMESPACE }}

      # -------------------------------
      # Deploy Databases
      # -------------------------------
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n ${{ inputs.NAMESPACE }}
          kubectl rollout status deployment/product-db-deployment -n ${{ inputs.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=product-db -n ${{ inputs.NAMESPACE }} --timeout=180s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n ${{ inputs.NAMESPACE }}
          kubectl rollout status deployment/order-db-deployment -n ${{ inputs.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=order-db -n ${{ inputs.NAMESPACE }} --timeout=180s

      # -------------------------------
      # Deploy Services using YAML files
      # -------------------------------
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n ${{ inputs.NAMESPACE }}
          kubectl rollout status deployment/product-service -n ${{ inputs.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=product-service -n ${{ inputs.NAMESPACE }} --timeout=180s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n ${{ inputs.NAMESPACE }}
          kubectl rollout status deployment/order-service -n ${{ inputs.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=order-service -n ${{ inputs.NAMESPACE }} --timeout=180s

      # -------------------------------
      # Wait for LoadBalancer services to get external IPs (if not staging)
      # -------------------------------
      - name: Wait for External IPs
        if: ${{ inputs.STAGING == false }}
        run: |
          echo "üåê Waiting for LoadBalancer services to get external IPs..."

          for svc in product-service order-service; do
            echo "‚è≥ Waiting for $svc external IP..."
            kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' svc/$svc -n ${{ inputs.NAMESPACE }} --timeout=300s
            EXTERNAL_IP=$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
          done

      # -------------------------------
      # Inject Service URLs into Frontend (MOVED AFTER SERVICES ARE DEPLOYED)
      # -------------------------------
      - name: Inject Service URLs into Frontend
        run: |
          FRONTEND_FILE=frontend/main.js

          if [ "${{ inputs.STAGING }}" = "true" ]; then
            # For staging, use ClusterIP
            PRODUCT_API_IP="http://$(kubectl get svc product-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.spec.clusterIP}'):8000"
            ORDER_API_IP="http://$(kubectl get svc order-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.spec.clusterIP}'):8000"
          else
            # For production, use LoadBalancer external IP
            PRODUCT_EXTERNAL_IP=$(kubectl get svc product-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            ORDER_EXTERNAL_IP=$(kubectl get svc order-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            PRODUCT_API_IP="http://${PRODUCT_EXTERNAL_IP}:8000"
            ORDER_API_IP="http://${ORDER_EXTERNAL_IP}:8000"
          fi

          echo "Injecting URLs into frontend:"
          echo "Product API: $PRODUCT_API_IP"
          echo "Order API: $ORDER_API_IP"

          # Replace placeholders safely
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_API_IP}|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|${ORDER_API_IP}|g" "$FRONTEND_FILE"

          # Verify the replacement worked
          echo "Verifying URL injection:"
          grep -n "http://" "$FRONTEND_FILE" || echo "No HTTP URLs found in frontend file"

      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and push frontend image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ inputs.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ inputs.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          sed -i "s|image: teddysit722hd.azurecr.io/frontend:latest|image: teddysit722hd.azurecr.io/frontend:${{ inputs.IMAGE_TAG }}|g" k8s/frontend.yaml
          kubectl apply -f k8s/frontend.yaml -n ${{ inputs.NAMESPACE }}
          kubectl rollout status deployment/frontend -n ${{ inputs.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=frontend -n ${{ inputs.NAMESPACE }} --timeout=180s

      - name: Log Service External IPs
        run: |
          echo "üåê Checking service IPs in namespace ${{ inputs.NAMESPACE }}..."
          kubectl get svc -n ${{ inputs.NAMESPACE }}

          for svc in frontend product-service order-service; do
            TYPE=$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.spec.type}' 2>/dev/null || echo "NotFound")
            if [ "$TYPE" = "LoadBalancer" ]; then
              EXTERNAL_IP=$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
            else
              echo "‚ÑπÔ∏è $svc is $TYPE"
            fi
          done

  # Rest of the jobs remain the same...
  post-deploy-integration-tests:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd util
          npm ci

      - name: Wait for Services to be Ready
        run: |
          NAMESPACE="${{ inputs.NAMESPACE }}"
          for svc in product-service order-service frontend; do
            echo "üîç Waiting for pods of $svc to be ready..."
            kubectl wait --for=condition=Ready pod -l app=$svc -n $NAMESPACE --timeout=180s
          done

      - name: Setup Port Forwarding
        run: |
          NAMESPACE="${{ inputs.NAMESPACE }}"

          setup_port_forward() {
            local service=$1
            local local_port=$2
            TARGET_PORT=$(kubectl get svc $service -n $NAMESPACE -o jsonpath='{.spec.ports[0].targetPort}')
            echo "üöÄ Setting up port forward for $service: localhost:$local_port -> service:$TARGET_PORT"
            pkill -f "port-forward.*:$local_port" || true
            kubectl port-forward svc/$service $local_port:$TARGET_PORT -n $NAMESPACE &
            PID=$!
            sleep 3
            if kill -0 $PID 2>/dev/null; then
              echo "‚úÖ Port forward established for $service (PID: $PID)"
              echo "üîó Access $service at http://localhost:$local_port"
            else
              echo "‚ùå Port forward for $service failed"
              return 1
            fi
          }

          setup_port_forward "product-service" 18000
          setup_port_forward "order-service" 18001
          setup_port_forward "frontend" 18002
          echo "‚è≥ Waiting 10 seconds for port forwards to stabilize..."
          sleep 10

      - name: Test Service Connectivity
        run: |
          test_endpoint() {
            local name=$1
            local url=$2
            local expected_status=${3:-200}
            echo "Testing $name at $url"
            for i in {1..10}; do
              if curl -f -s --max-time 5 "$url" >/dev/null 2>&1; then
                echo "‚úÖ $name is responding"
                return 0
              else
                echo "‚è≥ Attempt $i/10: $name not ready, retrying in 2s..."
                sleep 2
              fi
            done
            echo "‚ùå $name failed to respond after 10 attempts"
            return 1
          }

          test_endpoint "Product Service Health" "http://localhost:18000/health"
          test_endpoint "Order Service Health" "http://localhost:18001/health"
          test_endpoint "Frontend" "http://localhost:18002/" 200

      - name: Export Service URLs and Run Tests
        run: |
          export PRODUCT_API_IP="http://localhost:18000"
          export ORDER_API_IP="http://localhost:18001"
          export FRONTEND_URL="http://localhost:18002"

          echo "üîó Final service URLs:"
          echo "Product API: $PRODUCT_API_IP"
          echo "Order API: $ORDER_API_IP"
          echo "Frontend: $FRONTEND_URL"

          cd util
          npm test --testTimeout=30000

      - name: Cleanup Port Forwards
        if: always()
        run: |
          echo "üßπ Cleaning up port forwards..."
          pkill -f "kubectl port-forward" || true

  notify-email:
    needs: post-deploy-integration-tests
    uses: ./.github/workflows/plugin-send-email.yml
    with:
      email_to: "teddyhiny@gmail.com"
      email_subject: ${{ needs.post-deploy-integration-tests.result == 'success' && 'Deployment Succeeded' || 'Deployment Failed' }}
      email_body: |
        Deployment to namespace ${{ inputs.NAMESPACE }} has completed.
        Status: ${{ needs.deploy.result }}
        Image Tag: ${{ inputs.IMAGE_TAG }}
        Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    secrets:
      EMAIL_USER: ${{ secrets.EMAIL_USER }}
      EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
