name: Plugin - Deploy to AKS

on:
  workflow_call:
    inputs:
      NAMESPACE:
        required: true
        type: string
      IMAGE_TAG:
        required: true
        type: string
      STAGING:
        required: false
        type: boolean
        default: false
    secrets:
      AZURE_CREDENTIALS:
        required: true
      ACR_USERNAME:
        required: true
      ACR_PASSWORD:
        required: true
      ACR_LOGIN_SERVER:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      RESOURCE_GROUP: sit722devopsteddy-rg
      AKS_NAME: sit722devopsteddy-aks
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME

      - name: Create Namespace
        run: kubectl create namespace ${{ inputs.NAMESPACE }} || echo "Namespace exists"

      - name: Deploy Backend Services
        run: |
          for service in order_service product_service; do
            K8S_NAME=$(echo $service | sed 's/_/-/g')
            kubectl create deployment $K8S_NAME \
              --image=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            kubectl expose deployment $K8S_NAME \
              --type=LoadBalancer \
              --port=80 --target-port=80 --name=$K8S_NAME \
              -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            kubectl label deployment $K8S_NAME app=$K8S_NAME -n ${{ inputs.NAMESPACE }} --overwrite
            kubectl set image deployment/$K8S_NAME *=$ACR_LOGIN_SERVER/$service:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}
          done

      - name: Wait for Backend Deployments
        run: |
          DEPLOYMENTS=$(kubectl get deployments -n ${{ inputs.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}')
          for dep in $DEPLOYMENTS; do
            kubectl rollout status deployment/$dep -n ${{ inputs.NAMESPACE }} --timeout=300s
          done
          # Wait until LoadBalancer external IPs are ready
          for svc in product-service order-service; do
            while [ -z "$(kubectl get svc $svc -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')" ]; do
              echo "Waiting for external IP for $svc..."
              sleep 5
            done
          done

      - name: Get Backend External IPs
        run: |
          PRODUCT_API_IP=$(kubectl get svc product-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          ORDER_API_IP=$(kubectl get svc order-service -n ${{ inputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "PRODUCT_API=$PRODUCT_API_IP" >> $GITHUB_ENV
          echo "ORDER_API=$ORDER_API_IP" >> $GITHUB_ENV

      - name: Inject Backend IPs into Frontend main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|http://$PRODUCT_API:80|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://$ORDER_API:80|g" frontend/main.js

      - name: Build and Push Frontend Image
        run: |
          docker build -t $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} frontend/
          echo ${{ secrets.ACR_PASSWORD }} | docker login $ACR_LOGIN_SERVER -u ${{ secrets.ACR_USERNAME }} --password-stdin
          docker push $ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          kubectl create deployment frontend --image=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl expose deployment frontend --port=80 --target-port=80 --name=frontend -n ${{ inputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl set image deployment/frontend *=$ACR_LOGIN_SERVER/frontend:${{ inputs.IMAGE_TAG }} -n ${{ inputs.NAMESPACE }}
          kubectl label deployment frontend app=frontend -n ${{ inputs.NAMESPACE }} --overwrite

      - name: Wait for Frontend Deployment
        run: kubectl rollout status deployment/frontend -n ${{ inputs.NAMESPACE }} --timeout=300s

  post-deploy-integration-tests:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: |
          cd util
          npm ci

      - name: Run API integration tests
        run: |
          echo "ðŸ”— Setting up port forwarding for integration tests..."

          # Port forward all deployed services
          kubectl port-forward service/product-service 8000:80 -n ${{ inputs.NAMESPACE }} &
          PRODUCT_PF_PID=$!

          kubectl port-forward service/order-service 8001:80 -n ${{ inputs.NAMESPACE }} &
          ORDER_PF_PID=$!

          kubectl port-forward service/frontend 8080:80 -n ${{ inputs.NAMESPACE }} &
          FRONTEND_PF_PID=$!

          echo "Port forwarding PIDs: Product=$PRODUCT_PF_PID, Order=$ORDER_PF_PID, Frontend=$FRONTEND_PF_PID"

          # Wait for port forwards to establish
          echo "â³ Waiting for port forwards to establish..."
          sleep 15

          # Verify services are accessible
          echo "ðŸ” Verifying service accessibility..."

          # Test product service
          if curl -f -s http://localhost:8000/health >/dev/null 2>&1; then
            echo "âœ… Product service accessible on localhost:8000"
          else
            echo "âš ï¸ Product service not accessible"
          fi

          # Test order service
          if curl -f -s http://localhost:8001/health >/dev/null 2>&1; then
            echo "âœ… Order service accessible on localhost:8001"
          else
            echo "âš ï¸ Order service not accessible"
          fi

          # Test frontend
          if curl -f -s http://localhost:8080 >/dev/null 2>&1; then
            echo "âœ… Frontend accessible on localhost:8080"
          else
            echo "âš ï¸ Frontend not accessible"
          fi

          # Set environment variables for tests
          export PRODUCT_API_IP="http://localhost:8000"
          export ORDER_API_IP="http://localhost:8001"
          export FRONTEND_URL="http://localhost:8080"

          echo "ðŸ§ª Running integration tests..."
          cd util

          # Run tests with extended timeout
          npm test --testTimeout=30000 || {
            echo "âŒ Integration tests failed"
            # Cleanup on failure
            kill $PRODUCT_PF_PID $ORDER_PF_PID $FRONTEND_PF_PID 2>/dev/null || true
            pkill -f "kubectl port-forward" 2>/dev/null || true
            exit 1
          }

          echo "âœ… Integration tests completed successfully"

          # Cleanup port forwarding
          echo "ðŸ§¹ Cleaning up port forwarding..."
          kill $PRODUCT_PF_PID $ORDER_PF_PID $FRONTEND_PF_PID 2>/dev/null || true
          pkill -f "kubectl port-forward" 2>/dev/null || true

          echo "âœ… Port forwarding cleanup complete"

  notify-email:
    needs: deploy
    runs-on: ubuntu-latest
    if: ${{ inputs.STAGING == false }}
    steps:
      - name: Send Production Deployment Email
        uses: ./.github/workflows/plugin-send-email.yml
        with:
          email_to: "ops-team@example.com"
          email_subject: ${{ needs.deploy.result == 'success' && 'Production Deployment Succeeded' || 'Production Deployment Failed' }}
          email_body: |
            Production deployment to namespace ${{ inputs.NAMESPACE }} has completed.
            Status: ${{ needs.deploy.result }}
            Image Tag: ${{ inputs.IMAGE_TAG }}
            Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
